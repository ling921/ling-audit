<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>

  <data name="TypeParameterMustBeNullable_Title" xml:space="preserve">
    <value>Type parameter must be nullable</value>
    <comment>Title of the diagnostic for type parameters that must be nullable</comment>
  </data>
  <data name="TypeParameterMustBeNullable_Message" xml:space="preserve">
    <value>Type parameter '{0}' must be nullable</value>
    <comment>Message shown when a type parameter is not nullable</comment>
  </data>
  <data name="TypeParameterMustBeNullable_Description" xml:space="preserve">
    <value>The type parameter is marked with the MustNullable attribute, indicating that it must be a nullable type. This ensures that the type can represent the absence of a value.</value>
    <comment>Detailed explanation of why the type parameter is marked as must be nullable and how to fix it</comment>
  </data>

  <data name="AuditNotSupportedForValueType_Title" xml:space="preserve">
    <value>Audit operations not supported on value types</value>
    <comment>Title of the diagnostic for value types that cannot be audited</comment>
  </data>
  <data name="AuditNotSupportedForValueType_Message" xml:space="preserve">
    <value>Type '{0}' is a value type and cannot be audited</value>
    <comment>Message shown when a value type attempts to implement audit interfaces</comment>
  </data>
  <data name="AuditNotSupportedForValueType_Description" xml:space="preserve">
    <value>Value types cannot be audited because they are copied by value and do not maintain identity. Consider using a reference type instead.</value>
    <comment>Detailed explanation of why value types cannot be audited and how to fix it</comment>
  </data>

  <data name="AuditRequiresPartialType_Title" xml:space="preserve">
    <value>Type must be partial for audit support</value>
    <comment>Title of the diagnostic for non-partial types</comment>
  </data>
  <data name="AuditRequiresPartialType_Message" xml:space="preserve">
    <value>Type '{0}' must be declared as partial to support auditing</value>
    <comment>Message shown when a type implementing audit interfaces is not partial</comment>
  </data>
  <data name="AuditRequiresPartialType_Description" xml:space="preserve">
    <value>The type must be declared as partial to allow source generator to implement audit functionality. Add the 'partial' modifier to the type declaration.</value>
    <comment>Detailed explanation of the partial requirement and how to fix it</comment>
  </data>

  <data name="AuditKeyTypeMismatch_Title" xml:space="preserve">
    <value>Key type mismatch in audit interfaces</value>
    <comment>Title of the diagnostic for inconsistent key types</comment>
  </data>
  <data name="AuditKeyTypeMismatch_Message" xml:space="preserve">
    <value>Type '{0}' has multiple key types in audit interfaces: {1}</value>
    <comment>Message shown when audit interfaces use different key types</comment>
  </data>
  <data name="AuditKeyTypeMismatch_Description" xml:space="preserve">
    <value>All audit interfaces implemented by a type must use the same key type. Review and align the key types across interfaces.</value>
    <comment>Detailed explanation of key type consistency requirement and how to fix it</comment>
  </data>

  <data name="UseAuditedInterface_Title" xml:space="preserve">
    <value>Consider using more comprehensive audit interface</value>
    <comment>Title of the suggestion for using a more comprehensive interface</comment>
  </data>
  <data name="UseAuditedInterface_Message" xml:space="preserve">
    <value>Consider using {0} interface instead</value>
    <comment>Message suggesting to use a more comprehensive audit interface</comment>
  </data>
  <data name="UseAuditedInterface_Description" xml:space="preserve">
    <value>A more comprehensive audit interface is available that provides additional auditing capabilities. Consider using it for better audit coverage.</value>
    <comment>Detailed explanation of why to use a more comprehensive interface</comment>
  </data>

</root>