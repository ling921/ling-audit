using Ling.Audit.SourceGenerators.Helpers;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Ling.Audit.SourceGenerators;

partial class AuditPropertyGenerator
{
    private static string GetGeneratedCode(ClassDeclarationSyntax classDeclaration, List<AuditPropertyInfo> properties)
    {
        var (namespaceName, containingTypes) = GetTypeContext(classDeclaration);

        var cb = new CodeBuilder();

        cb.AppendLine("""
            // <auto-generated/>

            #pragma warning disable
            #nullable enable annotations

            """);

        cb.AppendLine($"namespace {namespaceName}")
            .OpenBrace();

        foreach (var type in containingTypes)
        {
            cb.AppendFormatLine("partial {0} {1}", type.Keyword, type.Name)
                .OpenBrace();
        }

        cb.AppendFormatLine("[global::System.CodeDom.Compiler.GeneratedCode(\"Ling.Audit.SourceGenerators\", \"{0}\")]", AuditDefaults.Version)
            .AppendLine("[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]")
            .AppendFormatLine("partial class {0}", classDeclaration.Identifier.Text)
            .OpenBrace();

        var index = 0;
        foreach (var property in properties)
        {
            cb.AppendFormatLine("/// <inheritdoc cref=\"global::{0}\" />", property.InterfaceName.Replace("`1", "{TKey}"))
                .AppendFormatLine("public virtual {0} {1} {{ get; set; }}", property.PropertyType, property.PropertyName);

            if (++index < properties.Count)
            {
                cb.AppendLine();
            }
        }

        cb.CloseAllBrace();

        return cb.ToString();
    }

    private record TypeInfo(string Keyword, string Name);

    private static (string Namespace, List<TypeInfo> ContainingTypes) GetTypeContext(ClassDeclarationSyntax classDeclaration)
    {
        var types = new List<TypeInfo>();
        var parent = classDeclaration.Parent;
        var namespaceName = "global::System";

        while (parent != null)
        {
            switch (parent)
            {
                case ClassDeclarationSyntax classDecl:
                    types.Insert(0, new TypeInfo("class", classDecl.Identifier.Text));
                    break;

                case StructDeclarationSyntax structDecl:
                    types.Insert(0, new TypeInfo("struct", structDecl.Identifier.Text));
                    break;

                case RecordDeclarationSyntax recordDecl:
                    types.Insert(0, new TypeInfo("record", recordDecl.Identifier.Text));
                    break;

                case BaseNamespaceDeclarationSyntax namespaceDecl:
                    namespaceName = namespaceDecl.Name.ToString();
                    break;
            }

            parent = parent.Parent;
        }

        return (namespaceName, types);
    }
}
